const l=JSON.parse('{"key":"v-72780ac1","path":"/md/interview/x-interview-gq.html","title":"GQ面试题","lang":"zh-CN","frontmatter":{"date":"2023-01-21T00:00:00.000Z","author":"GQ","category":["面试"]},"headers":[{"level":2,"title":"JDK、JRE和JVM的区别","slug":"jdk、jre和jvm的区别","link":"#jdk、jre和jvm的区别","children":[]},{"level":2,"title":"为什么说Java语言\\"编译与解释并存\\"","slug":"为什么说java语言-编译与解释并存","link":"#为什么说java语言-编译与解释并存","children":[]},{"level":2,"title":"什么是平台无关性","slug":"什么是平台无关性","link":"#什么是平台无关性","children":[]},{"level":2,"title":"面向对象和面向过程","slug":"面向对象和面向过程","link":"#面向对象和面向过程","children":[]},{"level":2,"title":"封装","slug":"封装","link":"#封装","children":[]},{"level":2,"title":"继承","slug":"继承","link":"#继承","children":[]},{"level":2,"title":"多态","slug":"多态","link":"#多态","children":[]},{"level":2,"title":"构造方法的特点","slug":"构造方法的特点","link":"#构造方法的特点","children":[]},{"level":2,"title":"类变量、成员变量、局部变量","slug":"类变量、成员变量、局部变量","link":"#类变量、成员变量、局部变量","children":[]},{"level":2,"title":"访问修饰符","slug":"访问修饰符","link":"#访问修饰符","children":[]},{"level":2,"title":"重载和重写的区别","slug":"重载和重写的区别","link":"#重载和重写的区别","children":[]},{"level":2,"title":"接口和抽象类有什么共同点和区别","slug":"接口和抽象类有什么共同点和区别","link":"#接口和抽象类有什么共同点和区别","children":[]},{"level":2,"title":"== 和 equals的区别","slug":"和-equals的区别","link":"#和-equals的区别","children":[]},{"level":2,"title":"hashcode方法的作用","slug":"hashcode方法的作用","link":"#hashcode方法的作用","children":[]},{"level":2,"title":"Object类的常用方法","slug":"object类的常用方法","link":"#object类的常用方法","children":[]},{"level":2,"title":"浅拷贝和深拷贝","slug":"浅拷贝和深拷贝","link":"#浅拷贝和深拷贝","children":[]},{"level":2,"title":"如何实现深拷贝","slug":"如何实现深拷贝","link":"#如何实现深拷贝","children":[{"level":3,"title":"重写clone方法","slug":"重写clone方法","link":"#重写clone方法","children":[]},{"level":3,"title":"序列化实现深拷贝","slug":"序列化实现深拷贝","link":"#序列化实现深拷贝","children":[]}]},{"level":2,"title":"String s1 = \\"a\\"； 创建了多少个对象？","slug":"string-s1-a-创建了多少个对象","link":"#string-s1-a-创建了多少个对象","children":[]},{"level":2,"title":"String s2 = new String(“b”) 创建了多少个对象？","slug":"string-s2-new-string-b-创建了多少个对象","link":"#string-s2-new-string-b-创建了多少个对象","children":[]},{"level":2,"title":"String、StringBuffered和StringBuilder的区别","slug":"string、stringbuffered和stringbuilder的区别","link":"#string、stringbuffered和stringbuilder的区别","children":[]},{"level":2,"title":"String为什么不可变","slug":"string为什么不可变","link":"#string为什么不可变","children":[]},{"level":2,"title":"String为什么设计为不可变","slug":"string为什么设计为不可变","link":"#string为什么设计为不可变","children":[]},{"level":2,"title":"字符串常量池","slug":"字符串常量池","link":"#字符串常量池","children":[]},{"level":2,"title":"字符串拼接用\\"+\\"还是StringBuilder","slug":"字符串拼接用-还是stringbuilder","link":"#字符串拼接用-还是stringbuilder","children":[]},{"level":2,"title":"replaceFirst、replaceAll、replace区别","slug":"replacefirst、replaceall、replace区别","link":"#replacefirst、replaceall、replace区别","children":[]},{"level":2,"title":"String有哪些常用方法","slug":"string有哪些常用方法","link":"#string有哪些常用方法","children":[]},{"level":2,"title":"基本类型和包装类型的区别？","slug":"基本类型和包装类型的区别","link":"#基本类型和包装类型的区别","children":[]},{"level":2,"title":"包装类的缓存机制","slug":"包装类的缓存机制","link":"#包装类的缓存机制","children":[]},{"level":2,"title":"自动拆装箱","slug":"自动拆装箱","link":"#自动拆装箱","children":[]},{"level":2,"title":"包装类型的数值比较","slug":"包装类型的数值比较","link":"#包装类型的数值比较","children":[]},{"level":2,"title":"浮点数运算有丢失精度的风险","slug":"浮点数运算有丢失精度的风险","link":"#浮点数运算有丢失精度的风险","children":[]},{"level":2,"title":"超过 long 整型的数据应该如何表示？","slug":"超过-long-整型的数据应该如何表示","link":"#超过-long-整型的数据应该如何表示","children":[]},{"level":2,"title":"Error和Exception","slug":"error和exception","link":"#error和exception","children":[]},{"level":2,"title":"受检异常与非受检异常","slug":"受检异常与非受检异常","link":"#受检异常与非受检异常","children":[]},{"level":2,"title":"Throwable 类常用方法有哪些","slug":"throwable-类常用方法有哪些","link":"#throwable-类常用方法有哪些","children":[]},{"level":2,"title":"try-catch-finally 如何使用？","slug":"try-catch-finally-如何使用","link":"#try-catch-finally-如何使用","children":[]},{"level":2,"title":"throw和throws","slug":"throw和throws","link":"#throw和throws","children":[]},{"level":2,"title":"finally一定会被执行吗","slug":"finally一定会被执行吗","link":"#finally一定会被执行吗","children":[]},{"level":2,"title":"try-catch-resources","slug":"try-catch-resources","link":"#try-catch-resources","children":[]},{"level":2,"title":"自定义异常","slug":"自定义异常","link":"#自定义异常","children":[]},{"level":2,"title":"Collection和Collections区别","slug":"collection和collections区别","link":"#collection和collections区别","children":[]},{"level":2,"title":"List, Set, Queue, Map 四者的区别？","slug":"list-set-queue-map-四者的区别","link":"#list-set-queue-map-四者的区别","children":[]},{"level":2,"title":"ArrayList与Vector的区别","slug":"arraylist与vector的区别","link":"#arraylist与vector的区别","children":[]},{"level":2,"title":"ArrayList与LinkedList的区别","slug":"arraylist与linkedlist的区别","link":"#arraylist与linkedlist的区别","children":[]},{"level":2,"title":"ArrayList的扩容机制","slug":"arraylist的扩容机制","link":"#arraylist的扩容机制","children":[{"level":3,"title":"分析ArrayList扩容机制","slug":"分析arraylist扩容机制","link":"#分析arraylist扩容机制","children":[]},{"level":3,"title":"System.arraycopy() 和 Arrays.copyOf()方法","slug":"system-arraycopy-和-arrays-copyof-方法","link":"#system-arraycopy-和-arrays-copyof-方法","children":[]}]},{"level":2,"title":"comparable 和 Comparator 的区别","slug":"comparable-和-comparator-的区别","link":"#comparable-和-comparator-的区别","children":[]},{"level":2,"title":"无序性和不可重复性的含义是什么","slug":"无序性和不可重复性的含义是什么","link":"#无序性和不可重复性的含义是什么","children":[]},{"level":2,"title":"HashSet、LinkedHashSet 和 TreeSet","slug":"hashset、linkedhashset-和-treeset","link":"#hashset、linkedhashset-和-treeset","children":[]},{"level":2,"title":"HashSet如何检查重复","slug":"hashset如何检查重复","link":"#hashset如何检查重复","children":[]},{"level":2,"title":"TreeSet如何检查重复","slug":"treeset如何检查重复","link":"#treeset如何检查重复","children":[]},{"level":2,"title":"为什么重写equals方法还要重写hashCode方法？","slug":"为什么重写equals方法还要重写hashcode方法","link":"#为什么重写equals方法还要重写hashcode方法","children":[]},{"level":2,"title":"HashMap和Hashtable的区别","slug":"hashmap和hashtable的区别","link":"#hashmap和hashtable的区别","children":[]},{"level":2,"title":"HashMap的底层实现","slug":"hashmap的底层实现","link":"#hashmap的底层实现","children":[]},{"level":2,"title":"HashMap的扩容机制","slug":"hashmap的扩容机制","link":"#hashmap的扩容机制","children":[]},{"level":2,"title":"HashMap的长度为什么是2的幂次方","slug":"hashmap的长度为什么是2的幂次方","link":"#hashmap的长度为什么是2的幂次方","children":[]},{"level":2,"title":"HashMap线程不安全问题","slug":"hashmap线程不安全问题","link":"#hashmap线程不安全问题","children":[]},{"level":2,"title":"HashMap的几种遍历方式","slug":"hashmap的几种遍历方式","link":"#hashmap的几种遍历方式","children":[]},{"level":2,"title":"fail-fast和fail-safe","slug":"fail-fast和fail-safe","link":"#fail-fast和fail-safe","children":[{"level":3,"title":"fail-fast","slug":"fail-fast","link":"#fail-fast","children":[]},{"level":3,"title":"fail-safe","slug":"fail-safe","link":"#fail-safe","children":[]}]},{"level":2,"title":"如何在遍历的同时删除ArrayList中的元素","slug":"如何在遍历的同时删除arraylist中的元素","link":"#如何在遍历的同时删除arraylist中的元素","children":[]},{"level":2,"title":"CopyOnWriteArrayList","slug":"copyonwritearraylist","link":"#copyonwritearraylist","children":[]},{"level":2,"title":"CurrentHashMap的底层实现","slug":"currenthashmap的底层实现","link":"#currenthashmap的底层实现","children":[]},{"level":2,"title":"什么是泛型","slug":"什么是泛型","link":"#什么是泛型","children":[]},{"level":2,"title":"泛型的使用方式","slug":"泛型的使用方式","link":"#泛型的使用方式","children":[]},{"level":2,"title":"什么是类型擦除","slug":"什么是类型擦除","link":"#什么是类型擦除","children":[]},{"level":2,"title":"限定通配符和非限定通配符","slug":"限定通配符和非限定通配符","link":"#限定通配符和非限定通配符","children":[]},{"level":2,"title":"枚举的用法","slug":"枚举的用法","link":"#枚举的用法","children":[]},{"level":2,"title":"应用场景","slug":"应用场景","link":"#应用场景","children":[]},{"level":2,"title":"枚举实现单例","slug":"枚举实现单例","link":"#枚举实现单例","children":[]},{"level":2,"title":"枚举是如何序列化的","slug":"枚举是如何序列化的","link":"#枚举是如何序列化的","children":[]},{"level":2,"title":"元注解","slug":"元注解","link":"#元注解","children":[]},{"level":2,"title":"如何自定义一个注解","slug":"如何自定义一个注解","link":"#如何自定义一个注解","children":[]},{"level":2,"title":"注解的解析方法有哪几种？","slug":"注解的解析方法有哪几种","link":"#注解的解析方法有哪几种","children":[]},{"level":2,"title":"何谓反射","slug":"何谓反射","link":"#何谓反射","children":[]},{"level":2,"title":"反射的作用","slug":"反射的作用","link":"#反射的作用","children":[]},{"level":2,"title":"Class类","slug":"class类","link":"#class类","children":[]},{"level":2,"title":"获取Class对象的方式","slug":"获取class对象的方式","link":"#获取class对象的方式","children":[]},{"level":2,"title":"反射获取创建对象、获取属性和方法","slug":"反射获取创建对象、获取属性和方法","link":"#反射获取创建对象、获取属性和方法","children":[]},{"level":2,"title":"反射的优缺点？","slug":"反射的优缺点","link":"#反射的优缺点","children":[]},{"level":2,"title":"反射的应用场景","slug":"反射的应用场景","link":"#反射的应用场景","children":[]},{"level":2,"title":"Java IO流了解吗","slug":"java-io流了解吗","link":"#java-io流了解吗","children":[]},{"level":2,"title":"字符流与字节流","slug":"字符流与字节流","link":"#字符流与字节流","children":[]},{"level":2,"title":"字节与字符流的转换","slug":"字节与字符流的转换","link":"#字节与字符流的转换","children":[]},{"level":2,"title":"字节流与字符流的区别","slug":"字节流与字符流的区别","link":"#字节流与字符流的区别","children":[]},{"level":2,"title":"为什么需要转换流","slug":"为什么需要转换流","link":"#为什么需要转换流","children":[]},{"level":2,"title":"BIO、NIO和AIO","slug":"bio、nio和aio","link":"#bio、nio和aio","children":[]},{"level":2,"title":"什么是序列化与反序列化","slug":"什么是序列化与反序列化","link":"#什么是序列化与反序列化","children":[]},{"level":2,"title":"如果有些字段不想序列化怎么办","slug":"如果有些字段不想序列化怎么办","link":"#如果有些字段不想序列化怎么办","children":[]},{"level":2,"title":"Java如何实现序列化","slug":"java如何实现序列化","link":"#java如何实现序列化","children":[{"level":3,"title":"实现Serializable接口","slug":"实现serializable接口","link":"#实现serializable接口","children":[]},{"level":3,"title":"实现Externalizable接口","slug":"实现externalizable接口","link":"#实现externalizable接口","children":[]},{"level":3,"title":"JSON序列化","slug":"json序列化","link":"#json序列化","children":[]}]},{"level":2,"title":"Serializable 和 Externalizable 的区别","slug":"serializable-和-externalizable-的区别","link":"#serializable-和-externalizable-的区别","children":[]},{"level":2,"title":"serialversionuid的作用","slug":"serialversionuid的作用","link":"#serialversionuid的作用","children":[]},{"level":2,"title":"ArrayList的序列化机制","slug":"arraylist的序列化机制","link":"#arraylist的序列化机制","children":[]},{"level":2,"title":"如何自定义序列化","slug":"如何自定义序列化","link":"#如何自定义序列化","children":[]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":57.8,"words":17339},"filePathRelative":"md/interview/x-interview-gq.md","localizedDate":"2023年1月21日","excerpt":"<p><code>来源</code> <a href=\\"http://zgq.cool/#/docs\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">zgq.cool</a></p>\\n"}');export{l as data};
