import{_ as l,V as i,W as e,a0 as a}from"./framework-abcd85d4.js";const r={},d=a('<h1 id="数据库相关" tabindex="-1"><a class="header-anchor" href="#数据库相关" aria-hidden="true">#</a> 数据库相关</h1><h2 id="_1-sql原理" tabindex="-1"><a class="header-anchor" href="#_1-sql原理" aria-hidden="true">#</a> 1 SQL原理</h2><h3 id="什么是事务" tabindex="-1"><a class="header-anchor" href="#什么是事务" aria-hidden="true">#</a> 什么是事务？</h3><p>事务是指满足ACID特性的一组操作，可以通过commit提交或者rollback回滚</p><p>事务的基本特性：ACID</p><ul><li>A 原子性：指事务中的操作要么成功，要么不执行。</li><li>C 一致性：指从数据库中的一个状态到另一个状态一致性的过程，比如说A修改了一个数字，但是sql在执行过程中系统崩溃，最后也不会影响这个数字，因为事务没有提交。</li><li>I 隔离性：在事务提交之前，对其他事务是不可见的。</li><li>D 持久性：事务一旦提交，将永久的保存到数据库中。</li></ul><h3 id="数据库中的并发一致性问题" tabindex="-1"><a class="header-anchor" href="#数据库中的并发一致性问题" aria-hidden="true">#</a> 数据库中的并发一致性问题？</h3><p>并发环境下，事务的隔离性很难保证，可能出现一些并发问题，会导致事务脏读，不可重复读，幻读。</p><h3 id="事务的隔离等级" tabindex="-1"><a class="header-anchor" href="#事务的隔离等级" aria-hidden="true">#</a> 事务的隔离等级？</h3><p>uncommit：允许读取未提交的数据变更，可能发生脏读，不可重复读，幻读。</p><p>commit：允许读取已提交的数据变更，可能发生不可重复读，幻读。</p><p>repeatable read：多次读取数据都是一致的，可能发生幻读。</p><p>serializable：所有的事务都是隔离的，可以阻止脏读，幻读，不可重复读，但是十分影响性能，开发中一般也不会用到这个隔离级别。</p><h3 id="acid靠什么保证的" tabindex="-1"><a class="header-anchor" href="#acid靠什么保证的" aria-hidden="true">#</a> ACID靠什么保证的？</h3><p>A：由undo log日志保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行的sql</p><p>C：由代码层面保证</p><p>I：由MVCC保证</p><p>D：由内存+redo log来保证，mysql修改数据同时在内存和redo log记录这次操作，事务提交的时候通过redo log刷盘，宕机的时候可以从redo log恢复</p><h3 id="sql优化经验" tabindex="-1"><a class="header-anchor" href="#sql优化经验" aria-hidden="true">#</a> sql优化经验</h3><ol><li>对查询进行优化，要尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</li><li>应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描。</li><li>应尽量避免在 where 子句中使用 != 或 &lt;&gt; 操作符，否则将引擎放弃使用索引而进行全表扫描。</li><li>应尽量避免在 where 子句中使用 or 来连接条件，如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描。</li><li>in 和 not in 也要慎用，否则会导致全表扫描。</li><li>如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。</li><li>应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。</li><li>不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</li><li>不要写一些没有意义的查询，如需要生成一个空表结构。</li><li>Update 语句，如果只更改1、2个字段，不要Update全部字段，否则频繁调用会引起明显的性能消耗，同时带来大量日志。</li><li>对于多张大数据量（这里几百条就算大了）的表JOIN，要先分页再JOIN，否则逻辑读会很高，性能很差。</li><li>select count(*) from table；这样不带任何条件的count会引起全表扫描，并且没有任何业务意义，是一定要杜绝的。</li><li>索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。</li><li>任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。</li><li>尽量避免大事务操作，提高系统并发能力。</li><li>尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。</li><li>尽量避免使用游标，因为游标的效率较差，如果游标操作的数据比较大，那么就应该考虑改写。</li></ol><h3 id="_1-6-从准备更新一条数据到事务的提交的流程描述" tabindex="-1"><a class="header-anchor" href="#_1-6-从准备更新一条数据到事务的提交的流程描述" aria-hidden="true">#</a> 1.6 从准备更新一条数据到事务的提交的流程描述？</h3><ul><li>首先执行器根据 MySQL 的执行计划来查询数据，先是从缓存池中查询数据，如果没有就会去数据库中查询，如果查询到了就将其放到缓存池中</li><li>在数据被缓存到缓存池的同时，会写入 undo log 日志文件</li><li>更新的动作是在 BufferPool 中完成的，同时会将更新后的数据添加到 redo log buffer 中</li><li>完成以后就可以提交事务，在提交的同时会做以下三件事 <ul><li>将redo log buffer中的数据刷入到 redo log 文件中</li><li>将本次操作记录写入到 bin log文件中</li><li>将 bin log 文件名字和更新内容在 bin log 中的位置记录到redo log中，同时在 redo log 最后添加 commit 标记</li></ul></li></ul><h2 id="_2-mysql" tabindex="-1"><a class="header-anchor" href="#_2-mysql" aria-hidden="true">#</a> 2 MySQL</h2><h3 id="能说下myisam-和-innodb的区别吗" tabindex="-1"><a class="header-anchor" href="#能说下myisam-和-innodb的区别吗" aria-hidden="true">#</a> 能说下myisam 和 innodb的区别吗？</h3><p>myisam引擎是5.1版本之前的默认引擎，支持全文检索、压缩、空间函数等，但是不支持事务和行级锁， 所以一般用于有大量查询少量插入的场景来使用，而且myisam不支持外键，并且索引和数据是分开存储的。</p><p>innodb是基于B+Tree索引建立的，和myisam相反它支持事务、外键，并且通过MVCC来支持高并发，索引和数据存储在一起。</p><h3 id="mysql的索引有哪些" tabindex="-1"><a class="header-anchor" href="#mysql的索引有哪些" aria-hidden="true">#</a> MySQL的索引有哪些？</h3><ul><li>B+Tree索引</li></ul><p>MySQL的存储引擎默认用B+Tree索引。</p><ul><li>哈希索引</li></ul><p>哈希索引可以以时间复杂度为O(1)的时间进行查询数据，但是会破坏数据的有序性。</p><p>Innodb有一个特殊的功能“自适应哈希索引”，也就是多次使用同一个索引，会在B+Tree索引上创建一个新的哈希索引，让B+Tree索引拥有哈希</p><p>索引的一些优点，比如快速哈希查找。</p><ul><li>全文索引</li></ul><p>MyISAM支持全文索引，用于查找文本中的关键词，而不是比较相等。</p><p>全文索引采用倒排索引实现，也就是记录着关键词在文档中的映射。</p><p>Innodb在5.6.4之后也支持了全文索引。</p><ul><li>空间数据索引</li></ul><p>MyISAM支持空间数据索引，可以用于存储地理数据信息，可以从多个维度进行索引数据，可以有效的从各个维度组合查询。</p><h3 id="mysql的索引种类" tabindex="-1"><a class="header-anchor" href="#mysql的索引种类" aria-hidden="true">#</a> MySQL的索引种类</h3><ul><li><p>普通索引：仅加速查询</p></li><li><p>唯一索引：加速查询 + 列值唯一（可以有null）</p></li><li><p>主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并</p></li><li><p>全文索引：对文本的内容进行分词，进行搜索</p></li><li><p>索引合并，使用多个单列索引组合搜索</p></li><li><p>覆盖索引，select的数据列只用从索引中就能够取得，不必读取数据行，换句话说查询列要被所建的索引覆盖</p></li></ul><h3 id="什么是b-树" tabindex="-1"><a class="header-anchor" href="#什么是b-树" aria-hidden="true">#</a> 什么是B+树？</h3><p>B+树是基于B树和叶子节点顺序访问指针实现的， 具有B树的平衡性，并且通过叶子节点顺序访问指针提高了区间查询性能。</p><p>B+树中，一个节点的key从左到右是非递减排列的，如果某个指针的左右相邻key分别是key<sub>i</sub>和key<sub>i+1</sub>，且不为 null， 则该指针指向节点的所有 key 大于等于 key<sub>i</sub> 且小于等于 key<sub>i+1</sub>。</p><h3 id="mysql主从复制" tabindex="-1"><a class="header-anchor" href="#mysql主从复制" aria-hidden="true">#</a> MySQL主从复制？</h3><p>主要涉及三个线程：binlog线程，I/O线程，SQL线程</p><ul><li>binlog线程：负责将主服务器上的数据更改写入二进制日志中。</li><li>I/O线程：负责从主服务器中读取二进制日志，并写入从服务器中的中继日志中。</li><li>SQL线程：负责读取中继日志并重放其中的sql语句。</li></ul><p><strong>全同步复制：</strong> 主库写入binlog后，强制同步日志到从库，所有从库执行完毕后才返回给客户端，但是性能会受到严重的影响。</p><p><strong>半同步复制：</strong> 从库写入日志成功后返回ACK确认给主库，主库收到至少一个从库的确认就会认为写操作完成。</p><h3 id="mysql读写分离方案" tabindex="-1"><a class="header-anchor" href="#mysql读写分离方案" aria-hidden="true">#</a> MySQL读写分离方案?</h3><p>主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。</p><p>读写分离能提高性能的原因在于:</p><ul><li>主从服务器负责各自的读和写，极大程度缓解了锁的争用；</li><li>从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；</li><li>增加冗余，提高可用性。 读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。</li></ul>',53),h=[d];function n(s,o){return i(),e("div",null,h)}const p=l(r,[["render",n],["__file","x-interview-mysql.html.vue"]]);export{p as default};
