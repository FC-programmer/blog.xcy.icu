# 数据库相关
## 1 SQL原理

### 什么是事务？
事务是指满足ACID特性的一组操作，可以通过commit提交或者rollback回滚

事务的基本特性：ACID
* A 原子性：指事务中的操作要么成功，要么不执行。
* C 一致性：指从数据库中的一个状态到另一个状态一致性的过程，比如说A修改了一个数字，但是sql在执行过程中系统崩溃，最后也不会影响这个数字，因为事务没有提交。
* I 隔离性：在事务提交之前，对其他事务是不可见的。
* D 持久性：事务一旦提交，将永久的保存到数据库中。

### 数据库中的并发一致性问题？
并发环境下，事务的隔离性很难保证，可能出现一些并发问题，会导致事务脏读，不可重复读，幻读。

### 事务的隔离等级？
UnCommit：允许读取未提交的数据变更，可能发生脏读，不可重复读，幻读。

Commit：允许读取已提交的数据变更，可能发生不可重复读，幻读。

Repeatable_Read：多次读取数据都是一致的，可能发生幻读。

Serializable：所有的事务都是隔离的，可以阻止脏读，幻读，不可重复读，但是十分影响性能，开发中一般也不会用到这个隔离级别。

### ACID靠什么保证的？
A：由undo log日志保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行的sql

C：由代码层面保证

I：由MVCC保证

D：由内存+redo log来保证，mysql修改数据同时在内存和redo log记录这次操作，事务提交的时候通过redo log刷盘，宕机的时候可以从redo log恢复

### sql优化经验
1. 对查询进行优化，要尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。
2. 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描。 
3. 应尽量避免在 where 子句中使用 != 或 <> 操作符，否则将引擎放弃使用索引而进行全表扫描。
4. 应尽量避免在 where 子句中使用 or 来连接条件，如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描。
5. in 和 not in 也要慎用，否则会导致全表扫描。
6. 如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。
7. 应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。
8. 不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。
9. 不要写一些没有意义的查询，如需要生成一个空表结构。
10. Update 语句，如果只更改1、2个字段，不要Update全部字段，否则频繁调用会引起明显的性能消耗，同时带来大量日志。
11. 对于多张大数据量（这里几百条就算大了）的表JOIN，要先分页再JOIN，否则逻辑读会很高，性能很差。
12. select count(*) from table；这样不带任何条件的count会引起全表扫描，并且没有任何业务意义，是一定要杜绝的。
13. 索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。
14. 任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。
15. 尽量避免大事务操作，提高系统并发能力。
16. 尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。
17. 尽量避免使用游标，因为游标的效率较差，如果游标操作的数据比较大，那么就应该考虑改写。

### 1.6 从准备更新一条数据到事务的提交的流程描述？
* 首先执行器根据 MySQL 的执行计划来查询数据，先是从缓存池中查询数据，如果没有就会去数据库中查询，如果查询到了就将其放到缓存池中
* 在数据被缓存到缓存池的同时，会写入 undo log 日志文件
* 更新的动作是在 BufferPool 中完成的，同时会将更新后的数据添加到 redo log buffer 中
* 完成以后就可以提交事务，在提交的同时会做以下三件事 
  * 将redo log buffer中的数据刷入到 redo log 文件中
  * 将本次操作记录写入到 bin log文件中
  * 将 bin log 文件名字和更新内容在 bin log 中的位置记录到redo log中，同时在 redo log 最后添加 commit 标记

## 2 MySQL

### 能说下myisam 和 innodb的区别吗？
myisam引擎是5.1版本之前的默认引擎，支持全文检索、压缩、空间函数等，但是不支持事务和行级锁，
所以一般用于有大量查询少量插入的场景来使用，而且myisam不支持外键，并且索引和数据是分开存储的。

innodb是基于B+Tree索引建立的，和myisam相反它支持事务、外键，并且通过MVCC来支持高并发，索引和数据存储在一起。

### MySQL的索引有哪些？
* B+Tree索引

MySQL的存储引擎默认用B+Tree索引。

* 哈希索引

哈希索引可以以时间复杂度为O(1)的时间进行查询数据，但是会破坏数据的有序性。

Innodb有一个特殊的功能“自适应哈希索引”，也就是多次使用同一个索引，会在B+Tree索引上创建一个新的哈希索引，让B+Tree索引拥有哈希

索引的一些优点，比如快速哈希查找。

* 全文索引

MyISAM支持全文索引，用于查找文本中的关键词，而不是比较相等。

全文索引采用倒排索引实现，也就是记录着关键词在文档中的映射。

Innodb在5.6.4之后也支持了全文索引。

* 空间数据索引

MyISAM支持空间数据索引，可以用于存储地理数据信息，可以从多个维度进行索引数据，可以有效的从各个维度组合查询。

### MySQL的索引种类
* 普通索引：仅加速查询

* 唯一索引：加速查询 + 列值唯一（可以有null）

* 主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并

* 全文索引：对文本的内容进行分词，进行搜索

* 索引合并，使用多个单列索引组合搜索

* 覆盖索引，select的数据列只用从索引中就能够取得，不必读取数据行，换句话说查询列要被所建的索引覆盖

### 什么是B+树？
B+树是基于B树和叶子节点顺序访问指针实现的， 具有B树的平衡性，并且通过叶子节点顺序访问指针提高了区间查询性能。

B+树中，一个节点的key从左到右是非递减排列的，如果某个指针的左右相邻key分别是key~i~和key~i+1~，且不为 null，
则该指针指向节点的所有 key 大于等于 key~i~ 且小于等于 key~i+1~。

### MySQL主从复制？
主要涉及三个线程：binlog线程，I/O线程，SQL线程
* binlog线程：负责将主服务器上的数据更改写入二进制日志中。
* I/O线程：负责从主服务器中读取二进制日志，并写入从服务器中的中继日志中。
* SQL线程：负责读取中继日志并重放其中的sql语句。

**全同步复制：** 主库写入binlog后，强制同步日志到从库，所有从库执行完毕后才返回给客户端，但是性能会受到严重的影响。

**半同步复制：** 从库写入日志成功后返回ACK确认给主库，主库收到至少一个从库的确认就会认为写操作完成。

### MySQL读写分离方案?
主服务器处理写操作以及实时性要求比较高地读操作，而从服务器处理读操作。

读写分离能提高性能的原因在于:
* 主从服务器负责各自的读和写，极大程度缓解了锁的争用；
* 从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；
* 增加冗余，提高可用性。
读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。
